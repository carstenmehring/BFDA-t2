setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
#' SSD = sample size determination#
#' @details#
#' Finds the optimal sample size to achieve desired level of power.#
#
SSD <- function(BPA, criterion=c(1/3, 3), power=0.90, alpha=.05) {#
	# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (all(BPA$sim$d == 0)) {#
		# output for null effect#
		print(paste0(round(positive.results*100, 1), "% Type-I error rate achieved at n > ", n.crit, "\n"),#
		"This setting implies:\n", #
		round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		round(negative.results*100, 1), "% true-negative studies."#
		)#
	} else {#
		# output for true effect#
		print(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n"),#
		"This setting implies:\n", #
		round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		round(negative.results*100, 1), "% false-negative studies."#
		)#
	}	#
	library(ggplot2)#
	library(scales)#
	cat2 <- melt(categories, id.vars="n")#
	p1 <- ggplot(cat2, aes(x=n, y=value, fill=variable)) + geom_bar(stat="identity", width=1) + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	return(p1)#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results*100
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
print(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n"),#
		"This setting implies:\n", #
		round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		round(negative.results*100, 1), "% false-negative studies."#
		)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results*100
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
round(positive.results*100, 1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
print(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		round(negative.results*100, 1), "% false-negative studies."#
		)
)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
cat(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		round(negative.results*100, 1), "% false-negative studies."#
		))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
cat(paste0(round(positive.results*100, 1), "% Type-I error rate achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		"   ", round(negative.results*100, 1), "% true-negative studies."#
		))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
cat(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		"   ", round(negative.results*100, 1), "% false-negative studies."#
		))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
#' SSD = sample size determination#
#' @details#
#' Finds the optimal sample size to achieve desired level of power.#
#
SSD <- function(BPA, criterion=c(1/3, 3), power=0.90, alpha=.05) {#
	# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (all(BPA$sim$d == 0)) {#
		# output for null effect#
		cat(paste0(round(positive.results*100, 1), "% Type-I error rate achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		"   ", round(negative.results*100, 1), "% true-negative studies."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", round(inconclusive.results*100, 1), "% inconclusive studies and\n",#
		"   ", round(negative.results*100, 1), "% false-negative studies."#
		))#
	}	#
	library(ggplot2)#
	library(scales)#
	cat2 <- melt(categories, id.vars="n")#
	p1 <- ggplot(cat2, aes(x=n, y=value, fill=variable)) + geom_bar(stat="identity", width=1) + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	return(p1)#
}#
#
#load("../../finalSims/sim0.5_step1.RData")#
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
#' SSD = sample size determination#
#' @details#
#' Finds the optimal sample size to achieve desired level of power.#
#
SSD <- function(BPA, criterion=c(1/3, 3), power=0.90, alpha=.05) {#
	# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (all(BPA$sim$d == 0)) {#
		# output for null effect#
		cat(paste0(round(positive.results*100, 1), "% Type-I error rate achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive studies and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% true-negative studies."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive studies and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% false-negative studies."#
		))#
	}	#
	library(ggplot2)#
	library(scales)#
	cat2 <- melt(categories, id.vars="n")#
	p1 <- ggplot(cat2, aes(x=n, y=value, fill=variable)) + geom_bar(stat="identity", width=1) + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	return(p1)#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.80, criterion=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.90, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.80, criterion=c(1/3, 10))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
# asymmetric boundaries at 0.5 and 10#
SSD(sim, power=.80, criterion=c(0.5, 10))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.80, criterion=c(0.5, 10))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.80, criterion=c(1/4, 10))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0..RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.RData")
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.3.RData")
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.5.prior.RData")
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.RData")
sim
str(sim)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.3.RData")
sim
str(sim)
setwd('/Volumes/linuxcluster/BPA')
library(BPA)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.5.prior.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.RData")
str(sim)
BPA0 <- sim
BPA0.ttest.2 <- sim
BPA0.ttest.2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
sim <- BPA.sim.ttest.2(d=0, n.min=20, n.max=500, boundary=Inf, stepsize=NA, design="sequential", B=1000, verbose=TRUE, cores=2)#
save(sim, file="../../finalSims/sim.0b.RData")
sim
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.80, criterion=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.90, criterion=c(1/3, 3))
BPA <- sim
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
criterion=c(1/3, 3)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
power=0.90
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
alpha=.05
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
n.crit
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
analysis.mode <- ifelse(all(BPA$sim$d == 0), "H0", "H1")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
analysis.mode
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
n.crit <- categories$n[which(categories$negative.results <= alpha)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
n.crit
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$n
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$negative.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$positive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$n[which(categories$positive.results <= alpha)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
inconclusive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
negative.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
n.crit <- categories$n[which(categories$positive.results <= alpha)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
positive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
inconclusive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
negative.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
criterion=c(1/3, 3)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
alpha=.025
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
alpha=.025
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# determine the mode: H1 or H0-mode?#
	analysis.mode <- ifelse(all(BPA$sim$d == 0), "H0", "H1")#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	if (analysis.mode == "H1") {#
		n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	} else {#
		n.crit <- categories$n[which(categories$positive.results <= alpha)[1]]#
	}#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (analysis.mode == "H0") {#
		# output for null effect#
		cat(paste0(round(positive.results*100, 1), "% Type-I error rate achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		"   ", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive studies and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% true-negative studies."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n > ", n.crit, "\n",#
		"This setting implies:\n", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive studies and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% false-negative studies."#
		))#
	}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (analysis.mode == "H0") {#
		# output for null effect#
		cat(paste0("A ", round(positive.results*100, 1), "% long-term rate of Type-I errors is achieved at n >= ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		"   ", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% true-negative results."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n >= ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% false-negative results."#
		))#
	}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
library(ggplot2)#
	library(scales)#
	cat2 <- melt(categories, id.vars="n")#
	p1 <- ggplot(cat2, aes(x=n, y=value, fill=variable)) + geom_bar(stat="identity", width=1) + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)
p1
head(cat2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
lag(cat2$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
lead(cat2$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
cat2$n_next <- lead(cat2$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=value, ymax=value, fill=variable)) + geom_rect() + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=value, ymax=value, fill=variable)) + geom_rect()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=value, ymax=value, fill=variable)) + geom_rect(position=position_stack())
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=0, ymax=value, fill=variable)) + geom_rect(position=position_stack())
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=0, ymax=value, fill=variable)) + geom_rect()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, xmax=n_next, ymin=0, ymax=value, fill=variable)) + geom_rect(position=position_stack())
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(cat2, aes(xmin=n, y=0, xmax=n_next, ymin=0, ymax=value, fill=variable)) + geom_rect(position=position_stack())
head(cat2)
head(cat)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
head(categories)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$p_i <- categories$positive.results + categories$inconclusive.results
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
head(categories)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
cat2 <- melt(categories, id.vars="n")	#
	cat2$n_next <- lead(cat2$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories$n_next <- lead(categories$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
categories
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results), color=colors[1])
p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results), fill=colors[1])
p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=positive.results, ymax=p_i), fill=colors[2])
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=positive.results, ymax=p_i), fill=colors[2])
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=p_i, ymax=1), fill=colors[3])
p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
library(ggplot2)#
	library(scales)#
	# Compute some variables to allow stacked rects#
	categories$p_i <- categories$positive.results + categories$inconclusive.results#
	categories$n_next <- lead(categories$n)#
	cat2 <- melt(categories, id.vars="n")	#
	cat2$n_next <- lead(cat2$n)#
	p1 <- ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results), fill=colors[1])#
	if (length(logCriterion) == 2) {#
		p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=positive.results, ymax=p_i), fill=colors[2])#
	}#
	p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=p_i, ymax=1), fill=colors[length(colors)])#
	p1 <- p1 + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n > ", n.crit), size=3, hjust=1.1, vjust=1.5, fontface=2)
p1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
paste0(round(power*100), "% Type-I error rate achieved at n = ", n.crit)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
paste0(round(alpha*100), "% Type-I error rate achieved at n = ", n.crit)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=1.1, vjust=1.5, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=0, vjust=0, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=0, vjust=0, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=1, vjust=0, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=-0.2, vjust=-0.2, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=-0.1, vjust=-0.2, fontface=2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
#' SSD = sample size determination#
#' @details#
#' Finds the optimal sample size to achieve desired level of power.#
#' @param power The desired rate of true-positive results (in case of reality=H1)#
#' @param alpha The desired rate of false-positive results (in case of reality=H0)#
SSD <- function(BPA, criterion=c(1/3, 3), power=0.90, alpha=.025) {#
	# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# determine the mode: H1 or H0-mode?#
	analysis.mode <- ifelse(all(BPA$sim$d == 0), "H0", "H1")#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	if (analysis.mode == "H1") {#
		n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	} else {#
		n.crit <- categories$n[which(categories$positive.results <= alpha)[1]]#
	}#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (analysis.mode == "H0") {#
		# output for null effect#
		cat(paste0("A ", round(positive.results*100, 1), "% long-term rate of Type-I errors is achieved at n = ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		"   ", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% true-negative results."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n = ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% false-negative results."#
		))#
	}	#
	# ---------------------------------------------------------------------#
	# The plot#
	library(ggplot2)#
	library(scales)#
	# Compute some variables to allow stacked rects#
	categories$p_i <- categories$positive.results + categories$inconclusive.results#
	categories$n_next <- lead(categories$n)#
	cat2 <- melt(categories, id.vars="n")	#
	cat2$n_next <- lead(cat2$n)#
	p1 <- ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results), fill=colors[1])#
	if (length(logCriterion) == 2) {#
		p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=positive.results, ymax=p_i), fill=colors[2])#
	}#
	p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=p_i, ymax=1), fill=colors[length(colors)])#
	p1 <- p1 + theme_bw() + scale_y_continuous(labels=percent) + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	if (analysis.mode == "H1") {#
		p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n = ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	} else {#
		p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=-0.1, vjust=-0.2, fontface=2)#
	}#
	return(p1)#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.3.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
#' SSD = sample size determination#
#' @details#
#' Finds the optimal sample size to achieve desired level of power.#
#' @param power The desired rate of true-positive results (in case of reality=H1)#
#' @param alpha The desired rate of false-positive results (in case of reality=H0)#
SSD <- function(BPA, criterion=c(1/3, 3), power=0.90, alpha=.025) {#
	# just in case: order criterion#
	criterion <- sort(criterion)#
	logCriterion <- log(criterion)#
	# determine the mode: H1 or H0-mode?#
	analysis.mode <- ifelse(all(BPA$sim$d == 0), "H0", "H1")#
	# sanity check: only valid, if same numbers of replications at each n.#
	var.ns <- BPA$sim %>% group_by(n) %>% summarize(ns=n()) %>% summarise(var(.$ns))#
	if (var.ns>0) {stop("Not numbers of replications at each n - consider setting boundary=Inf in your BPA.sim function.")}#
	# categorize trajectories according to critical boundary#
	if (length(logCriterion) == 1 && logCriterion == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			BF.positive = sum(logBF > 1)/n(),#
			BF.negative = sum(logBF < 1)/n()#
		)#
	}#
	if (length(logCriterion) == 1) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion)/n(),#
			negative.results = sum(logBF <= logCriterion)/n()#
		)#
	}#
	if (length(logCriterion) == 2) {#
		categories <- BPA$sim %>% group_by(n) %>% summarize(#
			positive.results = sum(logBF > logCriterion[2])/n(),#
			inconclusive.results = sum(logBF <= logCriterion[2] & logBF > logCriterion[1])/n(),#
			negative.results = sum(logBF <= logCriterion[1])/n()#
		)#
	}#
	# find critical n where power [i.e., prob(positive result | assumed effect)] is desired power#
	if (analysis.mode == "H1") {#
		n.crit <- categories$n[which(categories$positive.results >= power)[1]]#
	} else {#
		n.crit <- categories$n[which(categories$positive.results <= alpha)[1]]#
	}#
	positive.results <- categories$positive.results[which(categories$n == n.crit)[1]]#
	inconclusive.results <- categories$inconclusive.results[which(categories$n == n.crit)[1]]#
	negative.results <- categories$negative.results[which(categories$n == n.crit)[1]]#
	# ---------------------------------------------------------------------#
	# The plot#
	if (length(logCriterion) == 1) {#
		colors <- c("green4", "red3")#
		color.labels <- c(#
			paste0("Posiive outcome with BF > ", round(criterion, 2)),#
			paste0("Negative outcome with BF < ", round(criterion, 2))#
		)#
	}#
	if (length(logCriterion) == 2) {#
		colors <- c("green4", "orange1", "red3")#
		color.labels <- c(#
			paste0("Positive with BF > ", round(criterion[2], 2)),#
			paste0("Inconclusive with ", round(criterion[1], 2), " < BF < ", round(criterion[2], 2)),#
			paste0("Negative with BF < ", round(criterion[1], 2))#
		)#
	}#
	# If delta==0, show output for H0 studies, else: output for H1 studies#
	if (analysis.mode == "H0") {#
		# output for null effect#
		cat(paste0("A ", round(positive.results*100, 1), "% long-term rate of Type-I errors is achieved at n = ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		"   ", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% true-negative results."#
		))#
	} else {#
		# output for true effect#
		cat(paste0(round(positive.results*100, 1), "% power achieved at n = ", n.crit, "\n",#
		"This setting implies long-term rates of:\n", #
		ifelse(length(logCriterion) == 2, #
			paste0(round(inconclusive.results*100, 1), "% inconclusive results and\n"),#
			""),#
		"   ", round(negative.results*100, 1), "% false-negative results."#
		))#
	}	#
	# ---------------------------------------------------------------------#
	# The plot#
	library(ggplot2)#
	library(scales)#
	# Compute some variables to allow stacked rects#
	categories$p_i <- categories$positive.results + categories$inconclusive.results#
	categories$n_next <- lead(categories$n)#
	cat2 <- melt(categories, id.vars="n")	#
	cat2$n_next <- lead(cat2$n)#
	p1 <- ggplot(categories, aes()) + geom_rect(aes(xmin=n, xmax=n_next, ymin=0, ymax=positive.results), fill=colors[1])#
	if (length(logCriterion) == 2) {#
		p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=positive.results, ymax=p_i), fill=colors[2])#
	}#
	p1 <- p1 + geom_rect(aes(xmin=n, xmax=n_next, ymin=p_i, ymax=1), fill=colors[length(colors)])#
	p1 <- p1 + theme_bw() + scale_y_continuous(labels=percent) + xlab("n") + ylab("% of studies") + scale_fill_manual("Study outcome", values=colors, labels=color.labels)#
	p1 <- p1 + annotate("segment", x=n.crit, xend=n.crit, y=0, yend=positive.results)#
	p1 <- p1 + annotate("segment", x=min(cat2$n), xend=n.crit, y=positive.results, yend=positive.results, linetype="dashed")#
	p1 <- p1 + annotate("point", x=n.crit, y=positive.results, size=3)#
	if (analysis.mode == "H1") {#
		p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(power*100), "% power achieved at n = ", n.crit), angle=90, size=3, hjust=1.1, vjust=1.5, fontface=2)#
	} else {#
		p1 <- p1 + annotate("text", x=n.crit, y=positive.results, label=paste0(round(alpha*100, 1), "% Type-I error rate achieved at n = ", n.crit), size=3, hjust=-0.1, vjust=-0.2, fontface=2)#
	}#
	return(p1)#
}
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.5.prior.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.3.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
load("../../finalSims/sim.0.5.prior.RData")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BPA/package/R')
SSD(sim, power=.50, criterion=c(1/3, 3))
sim
sim$sim
head(sim$sim)
